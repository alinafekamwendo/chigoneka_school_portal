
const { User } = require("../models"); // Import the User model
const { Op } = require("sequelize");
const bcrypt = require("bcryptjs"); // For password hashing
const jwt = require("jsonwebtoken"); // For authentication tokens

// Helper function to generate JWT token
const generateToken = (user) => {
  return jwt.sign(
    { username: user.username, id: user.id, role: user.role },
    process.env.JWT_SECRET, // Store your secret key in environment variables
    { expiresIn: "4h" } // Token expires in 4 hour
  );
};

// Create a new user
const createUser = async (req, res) => {
  try {
    const {
      firstName,
      lastName,
      username,
      role,
      password,
      address,
      email,
      phone,
      sex,
      profilePhoto,
    } = req.body;

    if (
      !firstName |
      !lastName |
      !username |
      !role |
      !password |
      !address |
      !email |
      !phone |
      !sex
    ) {
      return res.status(400).json({ error: "All fields are required" });
    }
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    const lowerCaseRole = role.toLowerCase();
    const upperCaseSex = sex.toUpperCase();
    const [user, created] = await User.findOrCreate({
      where: { username },
      defaults: {
        firstName,
        lastName,
        role: lowerCaseRole,
        password: hashedPassword,
        address,
        email,
        phone,
        sex: upperCaseSex,
        profilePhoto,
      },
    });

    if (!created) {
      return res.status(400).json({ error: "Username already exists" });
    }

    // Generate a token for the new user
    const token = generateToken(user);

    res.status(201).json({ user, token });
  } catch (error) {
    console.error("Error creating user:", error);
    if (error.name === "SequelizeUniqueConstraintError") {
      const errors = error.errors.map((err) => ({
        field: err.path,
        message: err.message,
      }));
      return res.status(400).json({ errors });
    } else {
      res
        .status(500)
        .json({ error: error.message || "An unexpected error occurred" });
    }
  }
};





// Update a user
const updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      firstName,
      lastName,
      username,
      role,
      email,
      phone,
      password,
      sex,
      profilePhoto,
    } = req.body;

    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Hash new password if provided
    let updatedFields = { firstName, lastName, username, role, email, phone };
    if (password) {
      updatedFields.password = await bcrypt.hash(password, 10);
    }

    await User.update(updatedFields, { where: { id } });

    const updatedUser = await User.findByPk(id, {
      attributes: { exclude: ["password", "deletedAt"] },
    });

    res.status(200).json(updatedUser);
  } catch (error) {
    console.error("Error updating user:", error);
    res.status(500).json({ error: "Failed to update user" });
  }
};





module.exports = {
  createUser,
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
  restoreUser,
  loginUser,
};
const { User } = require("../models"); // Import the User model
const { Op } = require("sequelize");
const bcrypt = require("bcryptjs"); // For password hashing
const jwt = require("jsonwebtoken"); // For authentication tokens
const multer = require("multer"); // For handling file uploads
const path = require("path");
const fs = require("fs");

// Configure Multer storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, "../uploads");
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${req.body.username}_${Date.now()}${path.extname(
      file.originalname
    )}`;
    cb(null, uniqueName);
  },
});

const upload = multer({ storage });

// Helper function to generate JWT token
const generateToken = (user) => {
  return jwt.sign(
    { username: user.username, id: user.id, role: user.role },
    process.env.JWT_SECRET, // Store your secret key in environment variables
    { expiresIn: "4h" } // Token expires in 4 hours
  );
};

// Create a new user
const createUser = async (req, res) => {
  try {
    upload.single("profilePhoto")(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ error: "Error uploading file" });
      }

      const {
        firstName,
        lastName,
        username,
        role,
        password,
        address,
        email,
        phone,
        sex,
      } = req.body;

      if (
        !firstName ||
        !lastName ||
        !username ||
        !role ||
        !password ||
        !address ||
        !email ||
        !phone ||
        !sex
      ) {
        return res.status(400).json({ error: "All fields are required" });
      }

      // Hash the password
      const hashedPassword = await bcrypt.hash(password, 10);

      const lowerCaseRole = role.toLowerCase();
      const upperCaseSex = sex.toUpperCase();

      // Construct profile picture URL if file is uploaded
      let profilePhotoUrl = null;
      if (req.file) {
        profilePhotoUrl = `/uploads/${req.file.filename}`;
      }

      const [user, created] = await User.findOrCreate({
        where: { username },
        defaults: {
          firstName,
          lastName,
          role: lowerCaseRole,
          password: hashedPassword,
          address,
          email,
          phone,
          sex: upperCaseSex,
          profilePhoto: profilePhotoUrl,
        },
      });

      if (!created) {
        return res.status(400).json({ error: "Username already exists" });
      }

      // Generate a token for the new user
      const token = generateToken(user);

      res.status(201).json({ user, token });
    });
  } catch (error) {
    console.error("Error creating user:", error);
    res
      .status(500)
      .json({ error: error.message || "An unexpected error occurred" });
  }
};

// Get all users
const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll({
      attributes: { exclude: ["password", "deletedAt"] }, // Exclude sensitive fields
      paranoid: true, // Ensure soft-deleted users are not included
    });
    res.status(200).json(users);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ error: "Failed to fetch users" });
  }
};
// Update a user (including profile photo update)
const updateUser = async (req, res) => {
  try {
    upload.single("profilePhoto")(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ error: "Error uploading file" });
      }

      const { id } = req.params;
      const {
        firstName,
        lastName,
        username,
        role,
        email,
        phone,
        password,
        sex,
      } = req.body;

      const user = await User.findByPk(id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Hash new password if provided
      let updatedFields = { firstName, lastName, username, role, email, phone };
      if (password) {
        updatedFields.password = await bcrypt.hash(password, 10);
      }

      // Handle profile picture update
      if (req.file) {
        // Delete the old profile picture if exists
        if (user.profilePhoto) {
          const oldPhotoPath = path.join(__dirname, "..", user.profilePhoto);
          if (fs.existsSync(oldPhotoPath)) {
            fs.unlinkSync(oldPhotoPath);
          }
        }

        updatedFields.profilePhoto = `/uploads/${req.file.filename}`;
      }

      await User.update(updatedFields, { where: { id } });

      const updatedUser = await User.findByPk(id, {
        attributes: { exclude: ["password", "deletedAt"] },
      });

      res.status(200).json(updatedUser);
    });
  } catch (error) {
    console.error("Error updating user:", error);
    res.status(500).json({ error: "Failed to update user" });
  }
};

// Serve uploaded files
const serveProfilePhoto = async (req, res) => {
  const { filename } = req.params;
  const filePath = path.join(__dirname, "../uploads", filename);

  if (fs.existsSync(filePath)) {
    res.sendFile(filePath);
  } else {
    res.status(404).json({ error: "File not found" });
  }
};

module.exports = {
  createUser,
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
  restoreUser,
  loginUser,
  serveProfilePhoto,
};
